# green thumb

The challenge description has a big clue - the text "has excellent (sub-ns) speed, a state (256 bits) that is large enough for any parallel application, and it passes all tests we are aware of." is directly taken from the reference code for xoshiro256starstar. Searching in Google/DDG will reveal that.

The random secret generator is intentionally very week. It just encodes integers generated by a PRNG seeded with the startup timestamp. Knowing the timestamp makes it easy to replicate the PRNG sequence, and thus the secrets that are generated.

Attempting to login as an existing user will show the user id - this can be used to determine how far along in the PRNG sequence that secret is. Combined with the QR code containing the secret, an offline attack is possible. For example, if an attacker is given the id `7` then their secret is from the 19, 20, and 21 values the PRNG generates (3 values per secret, so `(7 * 3) - 2`, `(7 * 3) - 1`, and `7 * 3`). The root user to attack is the always the first user generated and has an id of `1`.

## scripted solution

The `solver.py` script uses the randomgen package (which relies on numpy) for the RNG and pyotp to generate TOTP codes. Since we know the seed is a timestamp, using a reasonably recent timestamp makes it possible to iterate all possible seeds quickly. One week would be 604,800 seeds to check.

For each value, the PRNG is seeded and three 64-bit integer values are generated. A bytestring is created from those values and encoded as Base32. This is a potential OTP secret. pyotp takes that secret and the current time to generate a code, which is checked against the server until a correct value is found.
